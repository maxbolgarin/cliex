package cliex

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"regexp"
	"sync/atomic"
	"time"

	validation "github.com/go-ozzo/ozzo-validation/v4"
	"github.com/maxbolgarin/logze"
)

const (
	defaultUserAgent      = "Golang HTTP client"
	defaultRequestTimeout = 30 * time.Second
	defaultWaitTime       = 10 * time.Second
)

// HTTPAddressRegexp is used to match URLs starting with "http://" or "https://", with an optional "www." prefix.
var HTTPAddressRegexp = regexp.MustCompile(`^https?:\/\/(www\.)?([-a-zA-Z0-9@:%._\+~#=]{1,256}(\.|:)[a-zA-Z0-9()]{1,5}|:[0-9]{2,5})(/[-a-zA-Z0-9()@:%_\+.~#?&//=]*)*$`)

// Config is the config for the HTTP client.
type Config struct {
	// Address is the address of the server in format "http://localhost:8080" or "https://localhost:8080". It is used as a fallback if BaseURL is empty.
	Address string `yaml:"address" json:"address" env:"CLIEX_ADDRESS"`
	// BaseURL is the base URL of the server in format "http://localhost:8080" or "https://localhost:8080". If empty, it will be set to the value of Address.
	BaseURL string `yaml:"base_url" json:"base_url" env:"CLIEX_BASE_URL"`
	// UserAgent is the User-Agent header that is used for every request. Default is "Golang HTTP client".
	UserAgent string `yaml:"user_agent" json:"user_agent" env:"CLIEX_USER_AGENT"`
	// AuthToken is the Bearer token that is used for every request.
	AuthToken string `yaml:"auth_token" json:"auth_token" env:"CLIEX_AUTH_TOKEN"`
	// ProxyAddress is the address of the proxy server in format "http://localhost:3128". If empty, no proxy will be used.
	ProxyAddress string `yaml:"proxy_address" json:"proxy_address" env:"CLIEX_PROXY_ADDRESS"`
	// RequestTimeout is the timeout for every request in seconds. Default is 30 seconds.
	RequestTimeout time.Duration `yaml:"request_timeout" json:"request_timeout" env:"CLIEX_REQUEST_TIMEOUT"`
	// Insecure is the flag that allows to make requests to the server with invalid SSL certificate. Default is false.
	Insecure bool `yaml:"insecure" json:"insecure" env:"CLIEX_INSECURE"`

	// Logger is the logger that is used for logging. Default is logze.Log.
	Logger logze.Logger `yaml:"-" json:"-"`
}

func (c Config) Validate() error {
	return validation.ValidateStruct(&c,
		validation.Field(&c.Address, validation.Match(HTTPAddressRegexp).Error("invalid http address="+c.BaseURL)),
		validation.Field(&c.BaseURL, validation.Match(HTTPAddressRegexp).Error("invalid http address="+c.BaseURL)),
		validation.Field(&c.UserAgent),
		validation.Field(&c.AuthToken),
		validation.Field(&c.ProxyAddress, validation.Match(HTTPAddressRegexp).Error("invalid http address="+c.ProxyAddress)),
		validation.Field(&c.RequestTimeout, validation.Min(100*time.Millisecond)),
	)
}

// ResponseMapForTest is a map that contains functions that will be used to generate responses for tests.
type ResponseMapForTest map[string]func(context.Context, *http.Request) (any, error)

// GetConfigForTest returns a new Config with the server address set to a test server that will be closed when the given context is closed.
// The requests counter will be increased every time a request is made to the test server.
// The responses will be generated by the functions in the response map.
func GetConfigForTest(ctx context.Context, requestCounter *atomic.Int64, responseMap ResponseMapForTest) Config {
	srv := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
		requestCounter.Add(1)

		rw.Header().Set("Content-Type", "application/json")

		var out any
		if f, ok := responseMap[req.URL.Path]; ok {
			var err error
			if out, err = f(ctx, req); err != nil {
				http.Error(rw, err.Error(), http.StatusInternalServerError)
				return
			}
		}

		if out != nil {
			body, err := json.Marshal(out)
			if err != nil {
				http.Error(rw, err.Error(), http.StatusInternalServerError)
				return
			}
			if _, err = rw.Write(body); err != nil {
				http.Error(rw, err.Error(), http.StatusInternalServerError)
			}
		}

	}))
	go func() {
		<-ctx.Done()
		srv.Close()
	}()

	return Config{
		Address:  srv.URL,
		BaseURL:  srv.URL,
		Insecure: true,
	}
}
